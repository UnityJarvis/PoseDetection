# -*- coding: utf-8 -*-
"""Copy of Exercise_pose_detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1S6ohU6_j-wesZ-qEVGCXkd8RHYBkNXyC
"""

import pandas as pd
import numpy as np

file_1 = pd.read_csv('3d_distances.csv')
file_2 = pd.read_csv('angles.csv')
file_3 = pd.read_csv('labels.csv')
file_4 = pd.read_csv('landmarks.csv')
file_5 = pd.read_csv('xyz_distances.csv')

merged_data = pd.merge(file_4,file_5,on='pose_id')
merged_data = pd.merge(merged_data,file_1,on='pose_id')
merged_data = pd.merge(merged_data,file_2,on='pose_id')

merged_data = pd.merge(merged_data,file_3,on='pose_id')

merged_data.shape

# merged_data = pd.merge(file_1,file_2,on='pose_id')
# merged_data = pd.merge(merged_data,file_3,on='pose_id')
# merged_data = pd.merge(merged_data,file_4,on='pose_id')
# merged_data = pd.merge(merged_data,file_5,on='pose_id')
merged_data = merged_data.drop('pose_id',axis=1)
merged_data = merged_data.drop('right_knee_mid_hip_left_knee',axis=1)

merged_data.shape

merged_data['pose']

merged_data.iloc[:0,:]

merged_data.head()

# temp_col = merged_data['z_right_hip_avg_right_wrist_right_ankle'].copy()
# merged_data['z_right_hip_avg_right_wrist_right_ankle'] = merged_data['pose']
# merged_data['pose'] = temp_col

merged_data.iloc[:,-1]

# merged_data.rename(columns={'z_right_hip_avg_right_wrist_right_ankle':'pose_i'},inplace=True)
# merged_data.rename(columns={'pose':'z_right_hip_avg_right_wrist_right_ankle'},inplace=True)

# merged_data.iloc[:,-1]

# merged_data.rename(columns={'pose_i':'pose'},inplace=True)

merged_data.to_csv('/content/merged_dataa.csv')

merged_data['pose'].unique()

copy = merged_data

merged_data['pose'].value_counts()

from sklearn.model_selection import train_test_split
x= merged_data.drop(['pose'], axis='columns')
# x = merged_data.drop(['pose','pose_id'],axis='columns')
y = merged_data['pose']

from sklearn.preprocessing import LabelEncoder, MinMaxScaler
from sklearn.utils.class_weight import compute_class_weight
from sklearn.model_selection import cross_val_score, GridSearchCV, train_test_split
from sklearn.linear_model import LogisticRegression, SGDClassifier
from sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier
from sklearn.naive_bayes import MultinomialNB, GaussianNB, BernoulliNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.neural_network import MLPClassifier

encoder = LabelEncoder()
y = merged_data['pose']
y = encoder.fit_transform(y)

class_weights = compute_class_weight(class_weight='balanced', classes=np.unique(y), y=y)
class_weights_dict = {}
for idx, k in enumerate(class_weights):
    class_weights_dict[idx] = k

class_weights_dict

y

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
# x = x.drop(['pose_id'],axis=1)
x = scaler.fit_transform(x)
x

pip install scikit-learn

import sklearn.preprocessing

from sklearn.preprocessing import normalize
# sklearn.preprocessing.normalize(x, norm='l2', *, axis=1, copy=True, return_norm=False)

X_train,X_test,Y_train,Y_test = train_test_split(x,y,test_size=0.2,random_state=42)

# x_norm=sklearn.preprocessing.normalize(X_train, norm='l2', axis=0, copy=True, return_norm=False)
# x_test_norm=sklearn.preprocessing.normalize(X_test, norm='l2', axis=0, copy=True, return_norm=False)

from pandas.core.common import random_state
from sklearn.ensemble import RandomForestClassifier

classifier = RandomForestClassifier(random_state=42)

classifier.fit(X_train,Y_train)

# x_norm

from sklearn.metrics import accuracy_score

y_pred = classifier.predict(X_test)
accuracy_rf = accuracy_score(Y_test,y_pred)

print(accuracy_rf)

from sklearn.metrics import classification_report

print(classification_report(Y_test,y_pred))

target=merged_data['pose']

count=target.value_counts()
print(count)

X_train.shape

X_test.shape

from sklearn import svm
classifier_2 = svm.SVC()
classifier_2.fit(X_train,Y_train)

y_pred = classifier_2.predict(X_test)
accuracy_svm = accuracy_score(Y_test,y_pred)
print(accuracy_svm)

from sklearn.tree import DecisionTreeClassifier

classifier_3 = DecisionTreeClassifier(random_state = 0)

classifier_3.fit(X_train,Y_train)

y_pred = classifier_3.predict(X_test)
accuracy = accuracy_score(Y_test,y_pred)
print(accuracy)

print(classification_report(Y_test,y_pred))

pip install mediapipe

import math
import cv2
import numpy as np
from time import time
import mediapipe as mp
import matplotlib.pyplot as plt
from IPython.display import HTML

mp_pose = mp.solutions.pose

pose = mp_pose.Pose(static_image_mode=True, min_detection_confidence=0.3, model_complexity=2)

mp_drawing = mp.solutions.drawing_utils

pip install opencv-python

!pip install ipywebrtc

pip install mediapipe

import cv2
import mediapipe as mp
import numpy as np
import time
from google.colab.output import eval_js
from IPython.display import display, Javascript

# Function to capture video from webcam
def start_webcam(capture_width=640, capture_height=480, display_width=640, display_height=480):
    js = Javascript('''
        async function startWebcam() {
            const stream = await navigator.mediaDevices.getUserMedia({video: true});
            const video = document.createElement('video');
            video.srcObject = stream;
            video.play();
            return video;
        }
        ''')
    display(js)
    video = eval_js('startWebcam()')
    video.style.width = f'{display_width}px'
    video.style.height = f'{display_height}px'
    return video

# Initialize MediaPipe Pose model
mp_pose = mp.solutions.pose
pose = mp_pose.Pose(static_image_mode=False, min_detection_confidence=0.5, min_tracking_confidence=0.5)

# List of pose landmarks you want to store
points = [...]

def capture_image_and_landmarks():
    video = start_webcam()

    start_time = time.time()
    last_frame = None

    while time.time() - start_time <= 100:
        ret, frame = video.read()

        if not ret:
            print("Failed to capture frame.")
            break

        # Perform pose detection and landmark extraction here
        # You can use the 'frame' variable, which contains the webcam stream frame

        # Display the frame (optional)
        cv2.imshow('Webcam', frame)
        if cv2.waitKey(1) & 0xFF == 27:  # Press 'Esc' to exit
            break

    video.release()
    cv2.destroyAllWindows()

# sample_img  = cv2.imread(r"OIP.jpeg") #uploaded this image to colab
import cv2
import mediapipe as mp
import numpy as np
import time

# Initialize MediaPipe Pose model
mp_pose = mp.solutions.pose
pose = mp_pose.Pose(static_image_mode=False, min_detection_confidence=0.5, min_tracking_confidence=0.5)

# List of pose landmarks you want to store
points = [...]  # Add your desired pose landmarks here

# Function to capture image and store pose landmarks
def capture_image_and_landmarks():
    cap = cv2.VideoCapture(0)  # Use the appropriate camera index if you have multiple cameras

    start_time = time.time()
    last_frame = None

    while time.time() - start_time <= 10:
        ret, frame = cap.read()

        if not ret:
            print("Failed to capture frame.")
            break

        imgRGB = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)

        results = pose.process(imgRGB)

        if results.pose_landmarks:
            mp_drawing.draw_landmarks(frame, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)

            landmarks = results.pose_landmarks.landmark

            dict = {}
            for point, landmark in zip(points, landmarks):
                dict[point.name] = [landmark.x, landmark.y, landmark.z]

        last_frame = frame  # Update the last_frame with the latest frame

        cv2.imshow("Camera", frame)
        cv2.waitKey(1)

    cap.release()
    cv2.destroyAllWindows()

    return last_frame

# Call the function to capture images for 10 seconds and get the last frame
last_frame = capture_image_and_landmarks()

# Now you have the last_frame, and you can do further processing or saving if needed.
if last_frame is not None:
    plt.title("sample_Image")
    plt.axis('off')                       # Removes the labels
    plt.imshow(last_frame[:,:,::-1])      # Convert BGR to RGB as plt.show() expects RGB
    plt.show()                            # Display the image
else:
    print("No frames captured.")
# With this update, if the last_frame is None, it will print "No frames captured." Otherwise, it will display the last captured frame using plt.imshow(). This will prevent the 'NoneType' object subscriptable error.







# plt.figure(figsize = [10,10])                 #compress the size of image to 10x10
# plt.title("sample_Image");
# plt.axis('off');                    #removes the labels
# plt.imshow(last_frame[:,:,::-1]);  #converted bgr to rgb becoz to plt.show() expects rgb
# plt.show()                          #prints the image

results = pose.process(cv2.cvtColor(sample_img, cv2.COLOR_BGR2RGB))

image_height, image_width, _ = sample_img.shape

# Check if any landmarks are found.
if results.pose_landmarks:

    # Iterate two times as we only want to display first two landmark.
    for i in range(11,20):

        # Display the found landmarks after converting them into their original scale.
        print(f'{mp_pose.PoseLandmark(i).name}:')
        print(f'x: {results.pose_landmarks.landmark[mp_pose.PoseLandmark(i).value].x * image_width}')
        print(f'y: {results.pose_landmarks.landmark[mp_pose.PoseLandmark(i).value].y * image_height}')
        print(f'z: {results.pose_landmarks.landmark[mp_pose.PoseLandmark(i).value].z * image_width}')
        print(f'visibility: {results.pose_landmarks.landmark[mp_pose.PoseLandmark(i).value].visibility}\n')

img_copy = sample_img.copy()
height, width, _ = img_copy.shape
landmarks = []
# Check if any landmarks are found.
if results.pose_landmarks:

    # Draw Pose landmarks on the sample image.
    mp_drawing.draw_landmarks(image=img_copy, landmark_list=results.pose_landmarks, connections=mp_pose.POSE_CONNECTIONS)
    for landmark in results.pose_landmarks.landmark:

            # Append the landmark into the list.
            landmarks.append((int(landmark.x * width), int(landmark.y * height),
                                  (landmark.z * width)))
    # Specify a size of the figure.
    fig = plt.figure(figsize = [10, 10])

    # Display the output image with the landmarks drawn, also convert BGR to RGB for display.
    plt.title("Output");
    plt.axis('off');
    plt.imshow(img_copy[:,:,::-1]);
    plt.show()

points = mp_pose.PoseLandmark       # Landmarks
# path = r"/content/goddess"        # enter dataset path
data = []
for p in points:
  print(p)
for p in points:
        x = str(p)[13:]
        data.append(x + "_x")
        data.append(x + "_y")
        data.append(x + "_z")
        data.append(x + "_vis")
data = pd.DataFrame(columns = data)  # Empty dataset

from google.colab.patches import cv2_imshow

# img = cv2.imread(r"OIP.jpeg")

        # imageWidth, imageHeight = img.shape[:2]

imgRGB = cv2.cvtColor(sample_img, cv2.COLOR_BGR2RGB)
        # results = pose.process(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))

blackie = np.zeros(sample_img.shape) # Blank image

results = pose.process(imgRGB)

if results.pose_landmarks:
  mp_drawing.draw_landmarks(blackie, results.pose_landmarks, mp_pose.POSE_CONNECTIONS) # draw landmarks on blackie

  landmarks = results.pose_landmarks.landmark

  # for i,j in zip(points,landmarks):
  #   print(points[count])

  dict = {}
  for point, j in zip(points, landmarks):
    temp = temp + [j.x, j.y, j.z]
    # temp.extend([landmark.x, landmark.y, landmark.z])
    key = point.name
    value = [temp[count], temp[count+1], temp[count+2]]
    dict[key] = value
    count = count + 1

cv2_imshow(img)

cv2_imshow(blackie)

#xyz_distances
x_left_shoulder_left_wrist = dict['LEFT_WRIST'][0] - dict['LEFT_SHOULDER'][0]#(0.48930972814559937)-(-0.276510596275329)
y_left_shoulder_left_wrist = dict['LEFT_WRIST'][1] - dict['LEFT_SHOULDER'][1]#(0.143650084733963) -  (0.4948402941226959)
z_left_shoulder_left_wrist =  dict['LEFT_WRIST'][2] - dict['LEFT_SHOULDER'][2]#(-0.3052274286746979) - (0.14425188302993774)

x_right_shoulder_right_wrist = dict['RIGHT_WRIST'][0] - dict['RIGHT_SHOULDER'][0]#0.143650084733963 - 0.4948402941226959
y_right_shoulder_right_wrist = dict['RIGHT_WRIST'][1] - dict['RIGHT_SHOULDER'][1]#(-0.3052274286746979) -	0.14425188302993774
z_right_shoulder_right_wrist = dict['RIGHT_WRIST'][2] - dict['RIGHT_SHOULDER'][2]#0.48236632347106934 - (-0.3048369586467743)

x_left_hip_left_ankle	= dict['LEFT_ANKLE'][0] - dict['LEFT_HIP'][0]#0.5012699365615845 - (-0.12573319673538208)
y_left_hip_left_ankle	= dict['LEFT_ANKLE'][1] - dict['LEFT_HIP'][1]#0.1965891420841217 - 0.45757120847702026
z_left_hip_left_ankle	= dict['LEFT_ANKLE'][2] - dict['LEFT_HIP'][2]#(-0.24418438971042633)- 0.15223582088947296

x_right_hip_right_ankle	=  dict['RIGHT_ANKLE'][0] - dict['RIGHT_HIP'][0]
y_right_hip_right_ankle	= dict['RIGHT_ANKLE'][1] - dict['RIGHT_HIP'][1]
z_right_hip_right_ankle = dict['RIGHT_ANKLE'][2] - dict['RIGHT_HIP'][2]

x_left_hip_left_wrist	= dict['LEFT_WRIST'][0] - dict['LEFT_HIP'][0]
y_left_hip_left_wrist	=  dict['LEFT_WRIST'][1] - dict['LEFT_HIP'][1]
z_left_hip_left_wrist	=  dict['LEFT_WRIST'][2] - dict['LEFT_HIP'][2]

x_right_hip_right_wrist	= dict['RIGHT_WRIST'][0] - dict['RIGHT_HIP'][0]
y_right_hip_right_wrist	= dict['RIGHT_WRIST'][1] - dict['RIGHT_HIP'][1]
z_right_hip_right_wrist	= dict['RIGHT_WRIST'][2] - dict['RIGHT_HIP'][2]

x_left_shoulder_left_ankle	= dict['LEFT_ANKLE'][0] - dict['LEFT_SHOULDER'][0]
y_left_shoulder_left_ankle = dict['LEFT_ANKLE'][1] - dict['LEFT_SHOULDER'][1]
z_left_shoulder_left_ankle = dict['LEFT_ANKLE'][2] - dict['LEFT_SHOULDER'][2]

x_right_shoulder_right_ankle = dict['RIGHT_ANKLE'][0] - dict['RIGHT_SHOULDER'][0]
y_right_shoulder_right_ankle = dict['RIGHT_ANKLE'][1] - dict['RIGHT_SHOULDER'][1]
z_right_shoulder_right_ankle = dict['RIGHT_ANKLE'][2] - dict['RIGHT_SHOULDER'][2]

x_left_hip_right_wrist = dict['RIGHT_WRIST'][0] - dict['LEFT_HIP'][0]
y_left_hip_right_wrist = dict['RIGHT_WRIST'][1] - dict['LEFT_HIP'][1]
z_left_hip_right_wrist = dict['RIGHT_WRIST'][2] - dict['LEFT_HIP'][2]

x_right_hip_left_wrist = dict['LEFT_WRIST'][0] - dict['RIGHT_HIP'][0]
y_right_hip_left_wrist	= dict['LEFT_WRIST'][1] - dict['RIGHT_HIP'][1]
z_right_hip_left_wrist	= dict['LEFT_WRIST'][2] - dict['RIGHT_HIP'][2]

x_left_elbow_right_elbow = dict['RIGHT_ELBOW'][0] - dict['LEFT_ELBOW'][0]
y_left_elbow_right_elbow = dict['RIGHT_ELBOW'][1] - dict['LEFT_ELBOW'][1]
z_left_elbow_right_elbow = dict['RIGHT_ELBOW'][2] - dict['LEFT_ELBOW'][2]

x_left_knee_right_knee = dict['RIGHT_KNEE'][0] - dict['LEFT_KNEE'][0]
y_left_knee_right_knee	= dict['RIGHT_KNEE'][1] - dict['LEFT_KNEE'][1]
z_left_knee_right_knee	= dict['RIGHT_KNEE'][2] - dict['LEFT_KNEE'][2]

x_left_wrist_right_wrist = dict['RIGHT_WRIST'][0] - dict['LEFT_WRIST'][0]
y_left_wrist_right_wrisT = dict['RIGHT_WRIST'][1] - dict['LEFT_WRIST'][1]
z_left_wrist_right_wrist = dict['RIGHT_WRIST'][2] - dict['LEFT_WRIST'][2]

x_left_ankle_right_ankle = dict['RIGHT_ANKLE'][0] - dict['LEFT_ANKLE'][0]
y_left_ankle_right_ankle	= dict['RIGHT_ANKLE'][1] - dict['LEFT_ANKLE'][1]
z_left_ankle_right_ankle = dict['RIGHT_ANKLE'][2] - dict['LEFT_ANKLE'][2]

x_left_hip_avg_left_wrist_left_ankle = dict['LEFT_HIP'][0]-(dict['LEFT_WRIST'][0] + dict['LEFT_ANKLE'][0])/2
y_left_hip_avg_left_wrist_left_ankle = dict['LEFT_HIP'][1]-(dict['LEFT_WRIST'][1] + dict['LEFT_ANKLE'][1])/2
z_left_hip_avg_left_wrist_left_ankle = dict['LEFT_HIP'][2]-(dict['LEFT_WRIST'][2] + dict['LEFT_ANKLE'][2])/2

x_right_hip_avg_right_wrist_right_ankle = dict['RIGHT_HIP'][0]-(dict['RIGHT_WRIST'][0] + dict['RIGHT_ANKLE'][0])/2
y_right_hip_avg_right_wrist_right_ankle	= dict['RIGHT_HIP'][1]-(dict['RIGHT_WRIST'][1] + dict['RIGHT_ANKLE'][1])/2
z_right_hip_avg_right_wrist_right_ankle = dict['RIGHT_HIP'][2]-(dict['RIGHT_WRIST'][2] + dict['RIGHT_ANKLE'][2])/2

#xyz_distances
c1 = dict['LEFT_WRIST'][0] - dict['LEFT_SHOULDER'][0]
c2 = dict['LEFT_WRIST'][1] - dict['LEFT_SHOULDER'][1]
c3 =  dict['LEFT_WRIST'][2] - dict['LEFT_SHOULDER'][2]

c4 = dict['RIGHT_WRIST'][0] - dict['RIGHT_SHOULDER'][0]
c5 = dict['RIGHT_WRIST'][1] - dict['RIGHT_SHOULDER'][1]
c6 = dict['RIGHT_WRIST'][2] - dict['RIGHT_SHOULDER'][2]

c7	= dict['LEFT_ANKLE'][0] - dict['LEFT_HIP'][0]
c8	= dict['LEFT_ANKLE'][1] - dict['LEFT_HIP'][1]
c9	= dict['LEFT_ANKLE'][2] - dict['LEFT_HIP'][2]

c10	=  dict['RIGHT_ANKLE'][0] - dict['RIGHT_HIP'][0]
c11	= dict['RIGHT_ANKLE'][1] - dict['RIGHT_HIP'][1]
c12 = dict['RIGHT_ANKLE'][2] - dict['RIGHT_HIP'][2]

c13	= dict['LEFT_WRIST'][0] - dict['LEFT_HIP'][0]
c14	=  dict['LEFT_WRIST'][1] - dict['LEFT_HIP'][1]
c15=  dict['LEFT_WRIST'][2] - dict['LEFT_HIP'][2]

c16	= dict['RIGHT_WRIST'][0] - dict['RIGHT_HIP'][0]
c17	= dict['RIGHT_WRIST'][1] - dict['RIGHT_HIP'][1]
c18= dict['RIGHT_WRIST'][2] - dict['RIGHT_HIP'][2]

c19	= dict['LEFT_ANKLE'][0] - dict['LEFT_SHOULDER'][0]
c20 = dict['LEFT_ANKLE'][1] - dict['LEFT_SHOULDER'][1]
c21 = dict['LEFT_ANKLE'][2] - dict['LEFT_SHOULDER'][2]

c22 = dict['RIGHT_ANKLE'][0] - dict['RIGHT_SHOULDER'][0]
c23 = dict['RIGHT_ANKLE'][1] - dict['RIGHT_SHOULDER'][1]
c24 = dict['RIGHT_ANKLE'][2] - dict['RIGHT_SHOULDER'][2]

c25 = dict['RIGHT_WRIST'][0] - dict['LEFT_HIP'][0]
c26 = dict['RIGHT_WRIST'][1] - dict['LEFT_HIP'][1]
c27 = dict['RIGHT_WRIST'][2] - dict['LEFT_HIP'][2]

c28 = dict['LEFT_WRIST'][0] - dict['RIGHT_HIP'][0]
c29	= dict['LEFT_WRIST'][1] - dict['RIGHT_HIP'][1]
c30	= dict['LEFT_WRIST'][2] - dict['RIGHT_HIP'][2]

c31 = dict['RIGHT_ELBOW'][0] - dict['LEFT_ELBOW'][0]
c32 = dict['RIGHT_ELBOW'][1] - dict['LEFT_ELBOW'][1]
c33 = dict['RIGHT_ELBOW'][2] - dict['LEFT_ELBOW'][2]

c34 = dict['RIGHT_KNEE'][0] - dict['LEFT_KNEE'][0]
c35	= dict['RIGHT_KNEE'][1] - dict['LEFT_KNEE'][1]
c36	= dict['RIGHT_KNEE'][2] - dict['LEFT_KNEE'][2]

c37 = dict['RIGHT_WRIST'][0] - dict['LEFT_WRIST'][0]
c38 = dict['RIGHT_WRIST'][1] - dict['LEFT_WRIST'][1]
c39 = dict['RIGHT_WRIST'][2] - dict['LEFT_WRIST'][2]

c40 = dict['RIGHT_ANKLE'][0] - dict['LEFT_ANKLE'][0]
c41	= dict['RIGHT_ANKLE'][1] - dict['LEFT_ANKLE'][1]
c42= dict['RIGHT_ANKLE'][2] - dict['LEFT_ANKLE'][2]

c43 = dict['LEFT_HIP'][0]-(dict['LEFT_WRIST'][0] + dict['LEFT_ANKLE'][0])/2
c44 = dict['LEFT_HIP'][1]-(dict['LEFT_WRIST'][1] + dict['LEFT_ANKLE'][1])/2
c45 = dict['LEFT_HIP'][2]-(dict['LEFT_WRIST'][2] + dict['LEFT_ANKLE'][2])/2

c46 = dict['RIGHT_HIP'][0]-(dict['RIGHT_WRIST'][0] + dict['RIGHT_ANKLE'][0])/2
c47	= dict['RIGHT_HIP'][1]-(dict['RIGHT_WRIST'][1] + dict['RIGHT_ANKLE'][1])/2
c48 = dict['RIGHT_HIP'][2]-(dict['RIGHT_WRIST'][2] + dict['RIGHT_ANKLE'][2])/2

#3d_distances

c49 = np.sqrt((dict['LEFT_WRIST'][0] - dict['LEFT_SHOULDER'][0])**2 + (dict['LEFT_WRIST'][1] - dict['LEFT_SHOULDER'][1])**2 + (dict['LEFT_WRIST'][2] - dict['LEFT_SHOULDER'][2])**2)
c50 = np.sqrt((dict['RIGHT_WRIST'][0] - dict['RIGHT_SHOULDER'][0])**2 + (dict['RIGHT_WRIST'][1] - dict['RIGHT_SHOULDER'][1])**2 + (dict['RIGHT_WRIST'][2] - dict['RIGHT_SHOULDER'][2])**2)
c51= np.sqrt((dict['LEFT_ANKLE'][0] - dict['LEFT_HIP'][0])**2 + (dict['LEFT_ANKLE'][1] - dict['LEFT_HIP'][1])**2 + (dict['LEFT_ANKLE'][2] - dict['LEFT_HIP'][2])**2)
c52= np.sqrt((dict['RIGHT_ANKLE'][0] - dict['RIGHT_HIP'][0])**2 + (dict['RIGHT_ANKLE'][1] - dict['RIGHT_HIP'][1])**2 + (dict['RIGHT_ANKLE'][2] - dict['RIGHT_HIP'][2])**2)
c53	= np.sqrt((dict['LEFT_WRIST'][0] - dict['LEFT_HIP'][0])**2 + (dict['LEFT_WRIST'][1] - dict['LEFT_HIP'][1])**2 + (dict['LEFT_WRIST'][2] - dict['LEFT_HIP'][2])**2)
c54	= np.sqrt((dict['RIGHT_WRIST'][0] - dict['RIGHT_HIP'][0])**2 + (dict['RIGHT_WRIST'][1] - dict['RIGHT_HIP'][1])**2 + (dict['RIGHT_WRIST'][2] - dict['RIGHT_HIP'][2])**2)
c55 = np.sqrt((dict['LEFT_ANKLE'][0] - dict['LEFT_SHOULDER'][0])**2 + (dict['LEFT_ANKLE'][1] - dict['LEFT_SHOULDER'][1])**2 + (dict['LEFT_ANKLE'][2] - dict['LEFT_SHOULDER'][2])**2)
c56 = np.sqrt((dict['RIGHT_ANKLE'][0] - dict['RIGHT_SHOULDER'][0])**2 + (dict['RIGHT_ANKLE'][1] - dict['RIGHT_SHOULDER'][1])**2 + (dict['RIGHT_ANKLE'][2] - dict['RIGHT_SHOULDER'][2])**2)
c57 = np.sqrt((dict['RIGHT_WRIST'][0] - dict['LEFT_HIP'][0])**2 + (dict['RIGHT_WRIST'][1] - dict['LEFT_HIP'][1])**2 + (dict['RIGHT_WRIST'][2] - dict['LEFT_HIP'][2])**2)
c58 = np.sqrt((dict['LEFT_WRIST'][0] - dict['RIGHT_HIP'][0])**2 + (dict['LEFT_WRIST'][1] - dict['RIGHT_HIP'][1])**2 + (dict['LEFT_WRIST'][2] - dict['RIGHT_HIP'][2])**2)
c59= np.sqrt((dict['RIGHT_ELBOW'][0] - dict['LEFT_ELBOW'][0])**2 + (dict['RIGHT_ELBOW'][1] - dict['LEFT_ELBOW'][1])**2 + (dict['RIGHT_ELBOW'][2] - dict['LEFT_ELBOW'][2])**2)
c60 = np.sqrt((dict['RIGHT_KNEE'][0] - dict['LEFT_KNEE'][0])**2 + (dict['RIGHT_KNEE'][1] - dict['LEFT_KNEE'][1])**2 + (dict['RIGHT_KNEE'][2] - dict['LEFT_KNEE'][2])**2)
c61 = np.sqrt((dict['RIGHT_WRIST'][0] - dict['LEFT_WRIST'][0])**2 + (dict['RIGHT_WRIST'][1] - dict['LEFT_WRIST'][1])**2 + (dict['RIGHT_WRIST'][2] - dict['LEFT_WRIST'][2])**2)
c62 = np.sqrt((dict['RIGHT_ANKLE'][0] - dict['LEFT_ANKLE'][0])**2 + (dict['RIGHT_ANKLE'][1] - dict['LEFT_ANKLE'][1])**2 + (dict['RIGHT_ANKLE'][2] - dict['LEFT_ANKLE'][2])**2)

x_avg = (dict['LEFT_WRIST'][0] + dict['LEFT_ANKLE'][0])/2
y_avg = (dict['LEFT_WRIST'][1] + dict['LEFT_ANKLE'][1])/2
z_avg = (dict['LEFT_WRIST'][2] + dict['LEFT_ANKLE'][2])/2

c63 = np.sqrt((x_avg - dict['LEFT_HIP'][0])**2 + (y_avg - dict['LEFT_HIP'][1])**2 + (z_avg - dict['LEFT_HIP'][2])**2)



x_avg = (dict['RIGHT_WRIST'][0] + dict['LEFT_ANKLE'][0])/2
y_avg = (dict['RIGHT_WRIST'][1] + dict['LEFT_ANKLE'][1])/2
z_avg = (dict['RIGHT_WRIST'][2] + dict['LEFT_ANKLE'][2])/2
c64 = np.sqrt((x_avg - dict['RIGHT_HIP'][0])**2 + (y_avg - dict['RIGHT_HIP'][1])**2 + (z_avg - dict['RIGHT_HIP'][2])**2)

#angles
import math
import numpy as np

Ax = dict['RIGHT_SHOULDER'][0] - dict['RIGHT_ELBOW'][0]
Ay = dict['RIGHT_SHOULDER'][1] - dict['RIGHT_ELBOW'][1]
Az = dict['RIGHT_SHOULDER'][2] - dict['RIGHT_ELBOW'][2]
Bx = dict['RIGHT_SHOULDER'][0] - dict['RIGHT_HIP'][0]
By = dict['RIGHT_SHOULDER'][1] - dict['RIGHT_HIP'][1]
Bz = dict['RIGHT_SHOULDER'][2] - dict['RIGHT_HIP'][2]
AdotB = (Ax * Bx) + (Ay * By) + (Az * Bz)
modA = np.sqrt(Ax**2 + Ay**2 + Az**2)
modB = np.sqrt(Bx**2 + By**2 + Bz**2)
cos_angle = AdotB / (modA * modB)
angle = np.arccos(cos_angle)
c65= np.degrees(angle)

Ax = dict['LEFT_SHOULDER'][0] - dict['LEFT_ELBOW'][0]
Ay = dict['LEFT_SHOULDER'][1] - dict['LEFT_ELBOW'][1]
Az = dict['LEFT_SHOULDER'][2] - dict['LEFT_ELBOW'][2]
Bx = dict['LEFT_SHOULDER'][0] - dict['LEFT_HIP'][0]
By = dict['LEFT_SHOULDER'][1] - dict['LEFT_HIP'][1]
Bz = dict['LEFT_SHOULDER'][2] - dict['LEFT_HIP'][2]
AdotB = (Ax * Bx) + (Ay * By) + (Az * Bz)
modA = np.sqrt(Ax**2 + Ay**2 + Az**2)
modB = np.sqrt(Bx**2 + By**2 + Bz**2)
cos_angle = AdotB / (modA * modB)
angle = np.arccos(cos_angle)
c66	= np.degrees(angle)

Ax = (dict['LEFT_HIP'][0] + dict['RIGHT_HIP'][0])/2 - dict['RIGHT_KNEE'][0]
Ay =(dict['LEFT_HIP'][1] + dict['RIGHT_HIP'][1])/2 - dict['RIGHT_KNEE'][1]
Az = (dict['LEFT_HIP'][2] + dict['RIGHT_HIP'][2])/2 - dict['RIGHT_KNEE'][2]
Bx = (dict['LEFT_HIP'][0] + dict['RIGHT_HIP'][0])/2 - dict['LEFT_KNEE'][0]
By = (dict['LEFT_HIP'][1] + dict['RIGHT_HIP'][1])/2 - dict['LEFT_KNEE'][1]
Bz = (dict['LEFT_HIP'][2] + dict['RIGHT_HIP'][2])/2 - dict['LEFT_KNEE'][2]
AdotB = (Ax * Bx) + (Ay * By) + (Az * Bz)
modA = np.sqrt(Ax**2 + Ay**2 + Az**2)
modB = np.sqrt(Bx**2 + By**2 + Bz**2)
cos_angle = AdotB / (modA * modB)
angle = np.arccos(cos_angle)
c67 = np.degrees(angle)
# print(right_knee_mid_hip_left_knee )


Ax = dict['RIGHT_KNEE'][0] - dict['RIGHT_HIP'][0]
Ay = dict['RIGHT_KNEE'][1] - dict['RIGHT_HIP'][1]
Az = dict['RIGHT_KNEE'][2] - dict['RIGHT_HIP'][2]
Bx = dict['RIGHT_KNEE'][0] - dict['RIGHT_ANKLE'][0]
By = dict['RIGHT_KNEE'][1] - dict['RIGHT_ANKLE'][1]
Bz = dict['RIGHT_KNEE'][2] - dict['RIGHT_ANKLE'][2]
AdotB = (Ax * Bx) + (Ay * By) + (Az * Bz)
modA = np.sqrt(Ax**2 + Ay**2 + Az**2)
modB = np.sqrt(Bx**2 + By**2 + Bz**2)
cos_angle = AdotB / (modA * modB)
angle = np.arccos(cos_angle)
c68 = np.degrees(angle)

Ax = dict['LEFT_KNEE'][0] - dict['LEFT_HIP'][0]
Ay = dict['LEFT_KNEE'][1] - dict['LEFT_HIP'][1]
Az = dict['LEFT_KNEE'][2] - dict['LEFT_HIP'][2]
Bx = dict['LEFT_KNEE'][0] - dict['LEFT_ANKLE'][0]
By = dict['LEFT_KNEE'][1] - dict['LEFT_ANKLE'][1]
Bz = dict['LEFT_KNEE'][2] - dict['LEFT_ANKLE'][2]
AdotB = (Ax * Bx) + (Ay * By) + (Az * Bz)
modA = np.sqrt(Ax**2 + Ay**2 + Az**2)
modB = np.sqrt(Bx**2 + By**2 + Bz**2)
cos_angle = AdotB / (modA * modB)
angle = np.arccos(cos_angle)
c69=  np.degrees(angle)


Ax = dict['RIGHT_ELBOW'][0] - dict['RIGHT_WRIST'][0]
Ay = dict['RIGHT_ELBOW'][1] - dict['RIGHT_WRIST'][1]
Az = dict['RIGHT_ELBOW'][2] - dict['RIGHT_WRIST'][2]
Bx = dict['RIGHT_ELBOW'][0] - dict['RIGHT_SHOULDER'][0]
By = dict['RIGHT_ELBOW'][1] - dict['RIGHT_SHOULDER'][1]
Bz = dict['RIGHT_ELBOW'][2] - dict['RIGHT_SHOULDER'][2]
AdotB = (Ax * Bx) + (Ay * By) + (Az * Bz)
modA = np.sqrt(Ax**2 + Ay**2 + Az**2)
modB = np.sqrt(Bx**2 + By**2 + Bz**2)
cos_angle = AdotB / (modA * modB)
angle = np.arccos(cos_angle)
c70 = np.degrees(angle)

Ax = dict['LEFT_ELBOW'][0] - dict['LEFT_WRIST'][0]
Ay = dict['LEFT_ELBOW'][1] - dict['LEFT_WRIST'][1]
Az = dict['LEFT_ELBOW'][2] - dict['LEFT_WRIST'][2]
Bx = dict['LEFT_ELBOW'][0] - dict['LEFT_SHOULDER'][0]
By = dict['LEFT_ELBOW'][1] - dict['LEFT_SHOULDER'][1]
Bz = dict['LEFT_ELBOW'][2] - dict['LEFT_SHOULDER'][2]
AdotB = (Ax * Bx) + (Ay * By) + (Az * Bz)
modA = np.sqrt(Ax**2 + Ay**2 + Az**2)
modB = np.sqrt(Bx**2 + By**2 + Bz**2)
cos_angle = AdotB / (modA * modB)
angle = np.arccos(cos_angle)
c71 = np.degrees(angle)

for i in range(1,72):
  if(i!=67):
    temp.append(locals()['c' + str(i)])

#angles
# import pandas as pd

# file_2 = pd.read_csv('angles.csv')
# file_2.shape
# file_2.iloc[:1,:]
len(temp)

# right_elbow_right_shoulder_right_hip
# left_elbow_left_shoulder_left_hip
# right_knee_mid_hip_left_knee
# right_hip_right_knee_right_ankle
# left_hip_left_knee_left_ankle
# right_wrist_right_elbow_right_shoulder
# left_wrist_left_elbow_left_shoulder

file_4['z_right_ankle'][0]-file_4['z_left_ankle'][0]

print(file_5['z_left_ankle_right_ankle'][0])

len(temp)

merged_data.tail()

X_train

# print(temp)
temp = np.array(temp)         # Convert the temp list to a numpy array
temp = temp.reshape(-1, 169)  # Reshape to a 2D array with 33 columns (3 coordinates per landmark)
print(temp)

y_pred = classifier.predict(temp)

y_pred_class_names = encoder.inverse_transform(y_pred)
y_pred_class_names

